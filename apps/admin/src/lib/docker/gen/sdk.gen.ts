// This file is auto-generated by @hey-api/openapi-ts

import { client } from './client.gen.ts';
import type { Client, Options as Options2, TDataShape } from './client/index.ts';
import { buildPruneResponseTransformer, containerInspectResponseTransformer, containerListResponseTransformer, containerPruneResponseTransformer, containerWaitResponseTransformer, distributionInspectResponseTransformer, imageHistoryResponseTransformer, imageInspectResponseTransformer, imageListResponseTransformer, imagePruneResponseTransformer, nodeInspectResponseTransformer, nodeListResponseTransformer, serviceInspectResponseTransformer, serviceListResponseTransformer, swarmInspectResponseTransformer, systemDataUsageResponseTransformer, systemEventsResponseTransformer, systemInfoResponseTransformer, taskInspectResponseTransformer, taskListResponseTransformer, volumeCreateResponseTransformer, volumeInspectResponseTransformer, volumeListResponseTransformer, volumePruneResponseTransformer } from './transformers.gen.ts';
import type { BuildPruneData, BuildPruneErrors, BuildPruneResponses, ConfigCreateData, ConfigCreateErrors, ConfigCreateResponses, ConfigDeleteData, ConfigDeleteErrors, ConfigDeleteResponses, ConfigInspectData, ConfigInspectErrors, ConfigInspectResponses, ConfigListData, ConfigListErrors, ConfigListResponses, ConfigUpdateData, ConfigUpdateErrors, ConfigUpdateResponses, ContainerArchiveData, ContainerArchiveErrors, ContainerArchiveInfoData, ContainerArchiveInfoErrors, ContainerArchiveInfoResponses, ContainerArchiveResponses, ContainerAttachData, ContainerAttachErrors, ContainerAttachResponses, ContainerAttachWebsocketData, ContainerAttachWebsocketErrors, ContainerAttachWebsocketResponses, ContainerChangesData, ContainerChangesErrors, ContainerChangesResponses, ContainerCreateData, ContainerCreateErrors, ContainerCreateResponses, ContainerDeleteData, ContainerDeleteErrors, ContainerDeleteResponses, ContainerExecData, ContainerExecErrors, ContainerExecResponses, ContainerExportData, ContainerExportErrors, ContainerExportResponses, ContainerInspectData, ContainerInspectErrors, ContainerInspectResponses, ContainerKillData, ContainerKillErrors, ContainerKillResponses, ContainerListData, ContainerListErrors, ContainerListResponses, ContainerLogsData, ContainerLogsErrors, ContainerLogsResponses, ContainerPauseData, ContainerPauseErrors, ContainerPauseResponses, ContainerPruneData, ContainerPruneErrors, ContainerPruneResponses, ContainerRenameData, ContainerRenameErrors, ContainerRenameResponses, ContainerResizeData, ContainerResizeErrors, ContainerResizeResponses, ContainerRestartData, ContainerRestartErrors, ContainerRestartResponses, ContainerStartData, ContainerStartErrors, ContainerStartResponses, ContainerStatsData, ContainerStatsErrors, ContainerStatsResponses, ContainerStopData, ContainerStopErrors, ContainerStopResponses, ContainerTopData, ContainerTopErrors, ContainerTopResponses, ContainerUnpauseData, ContainerUnpauseErrors, ContainerUnpauseResponses, ContainerUpdateData, ContainerUpdateErrors, ContainerUpdateResponses, ContainerWaitData, ContainerWaitErrors, ContainerWaitResponses, DistributionInspectData, DistributionInspectErrors, DistributionInspectResponses, ExecInspectData, ExecInspectErrors, ExecInspectResponses, ExecResizeData, ExecResizeErrors, ExecResizeResponses, ExecStartData, ExecStartErrors, ExecStartResponses, GetPluginPrivilegesData, GetPluginPrivilegesErrors, GetPluginPrivilegesResponses, ImageBuildData, ImageBuildErrors, ImageBuildResponses, ImageCommitData, ImageCommitErrors, ImageCommitResponses, ImageCreateData, ImageCreateErrors, ImageCreateResponses, ImageDeleteData, ImageDeleteErrors, ImageDeleteResponses, ImageGetAllData, ImageGetAllErrors, ImageGetAllResponses, ImageGetData, ImageGetErrors, ImageGetResponses, ImageHistoryData, ImageHistoryErrors, ImageHistoryResponses, ImageInspectData, ImageInspectErrors, ImageInspectResponses, ImageListData, ImageListErrors, ImageListResponses, ImageLoadData, ImageLoadErrors, ImageLoadResponses, ImagePruneData, ImagePruneErrors, ImagePruneResponses, ImagePushData, ImagePushErrors, ImagePushResponses, ImageSearchData, ImageSearchErrors, ImageSearchResponses, ImageTagData, ImageTagErrors, ImageTagResponses, NetworkConnectData, NetworkConnectErrors, NetworkConnectResponses, NetworkCreateData, NetworkCreateErrors, NetworkCreateResponses, NetworkDeleteData, NetworkDeleteErrors, NetworkDeleteResponses, NetworkDisconnectData, NetworkDisconnectErrors, NetworkDisconnectResponses, NetworkInspectData, NetworkInspectErrors, NetworkInspectResponses, NetworkListData, NetworkListErrors, NetworkListResponses, NetworkPruneData, NetworkPruneErrors, NetworkPruneResponses, NodeDeleteData, NodeDeleteErrors, NodeDeleteResponses, NodeInspectData, NodeInspectErrors, NodeInspectResponses, NodeListData, NodeListErrors, NodeListResponses, NodeUpdateData, NodeUpdateErrors, NodeUpdateResponses, PluginCreateData, PluginCreateErrors, PluginCreateResponses, PluginDeleteData, PluginDeleteErrors, PluginDeleteResponses, PluginDisableData, PluginDisableErrors, PluginDisableResponses, PluginEnableData, PluginEnableErrors, PluginEnableResponses, PluginInspectData, PluginInspectErrors, PluginInspectResponses, PluginListData, PluginListErrors, PluginListResponses, PluginPullData, PluginPullErrors, PluginPullResponses, PluginPushData, PluginPushErrors, PluginPushResponses, PluginSetData, PluginSetErrors, PluginSetResponses, PluginUpgradeData, PluginUpgradeErrors, PluginUpgradeResponses, PutContainerArchiveData, PutContainerArchiveErrors, PutContainerArchiveResponses, SecretCreateData, SecretCreateErrors, SecretCreateResponses, SecretDeleteData, SecretDeleteErrors, SecretDeleteResponses, SecretInspectData, SecretInspectErrors, SecretInspectResponses, SecretListData, SecretListErrors, SecretListResponses, SecretUpdateData, SecretUpdateErrors, SecretUpdateResponses, ServiceCreateData, ServiceCreateErrors, ServiceCreateResponses, ServiceDeleteData, ServiceDeleteErrors, ServiceDeleteResponses, ServiceInspectData, ServiceInspectErrors, ServiceInspectResponses, ServiceListData, ServiceListErrors, ServiceListResponses, ServiceLogsData, ServiceLogsErrors, ServiceLogsResponses, ServiceUpdateData, ServiceUpdateErrors, ServiceUpdateResponses, SessionData, SessionErrors, SwarmInitData, SwarmInitErrors, SwarmInitResponses, SwarmInspectData, SwarmInspectErrors, SwarmInspectResponses, SwarmJoinData, SwarmJoinErrors, SwarmJoinResponses, SwarmLeaveData, SwarmLeaveErrors, SwarmLeaveResponses, SwarmUnlockData, SwarmUnlockErrors, SwarmUnlockkeyData, SwarmUnlockkeyErrors, SwarmUnlockkeyResponses, SwarmUnlockResponses, SwarmUpdateData, SwarmUpdateErrors, SwarmUpdateResponses, SystemAuthData, SystemAuthErrors, SystemAuthResponses, SystemDataUsageData, SystemDataUsageErrors, SystemDataUsageResponses, SystemEventsData, SystemEventsErrors, SystemEventsResponses, SystemInfoData, SystemInfoErrors, SystemInfoResponses, SystemPingData, SystemPingErrors, SystemPingHeadData, SystemPingHeadErrors, SystemPingHeadResponses, SystemPingResponses, SystemVersionData, SystemVersionErrors, SystemVersionResponses, TaskInspectData, TaskInspectErrors, TaskInspectResponses, TaskListData, TaskListErrors, TaskListResponses, TaskLogsData, TaskLogsErrors, TaskLogsResponses, VolumeCreateData, VolumeCreateErrors, VolumeCreateResponses, VolumeDeleteData, VolumeDeleteErrors, VolumeDeleteResponses, VolumeInspectData, VolumeInspectErrors, VolumeInspectResponses, VolumeListData, VolumeListErrors, VolumeListResponses, VolumePruneData, VolumePruneErrors, VolumePruneResponses, VolumeUpdateData, VolumeUpdateErrors, VolumeUpdateResponses } from './types.gen.ts';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * List containers
 *
 * Returns a list of containers. For details on the format, see the
 * [inspect endpoint](#operation/ContainerInspect).
 *
 * Note that it uses a different, smaller representation of a container
 * than inspecting a single container. For example, the list of linked
 * containers is not propagated .
 *
 */
export const containerList = <ThrowOnError extends boolean = false>(options?: Options<ContainerListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ContainerListResponses, ContainerListErrors, ThrowOnError>({
        responseTransformer: containerListResponseTransformer,
        responseType: 'json',
        url: '/containers/json',
        ...options
    });
};

/**
 * Create a container
 */
export const containerCreate = <ThrowOnError extends boolean = false>(options: Options<ContainerCreateData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerCreateResponses, ContainerCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Inspect a container
 *
 * Return low-level information about a container.
 */
export const containerInspect = <ThrowOnError extends boolean = false>(options: Options<ContainerInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerInspectResponses, ContainerInspectErrors, ThrowOnError>({
        responseTransformer: containerInspectResponseTransformer,
        responseType: 'json',
        url: '/containers/{id}/json',
        ...options
    });
};

/**
 * List processes running inside a container
 *
 * On Unix systems, this is done by running the `ps` command. This endpoint
 * is not supported on Windows.
 *
 */
export const containerTop = <ThrowOnError extends boolean = false>(options: Options<ContainerTopData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerTopResponses, ContainerTopErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/top',
        ...options
    });
};

/**
 * Get container logs
 *
 * Get `stdout` and `stderr` logs from a container.
 *
 * Note: This endpoint works only for containers with the `json-file` or
 * `journald` logging driver.
 *
 */
export const containerLogs = <ThrowOnError extends boolean = false>(options: Options<ContainerLogsData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerLogsResponses, ContainerLogsErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/logs',
        ...options
    });
};

/**
 * Get changes on a container’s filesystem
 *
 * Returns which files in a container's filesystem have been added, deleted,
 * or modified. The `Kind` of modification can be one of:
 *
 * - `0`: Modified ("C")
 * - `1`: Added ("A")
 * - `2`: Deleted ("D")
 *
 */
export const containerChanges = <ThrowOnError extends boolean = false>(options: Options<ContainerChangesData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerChangesResponses, ContainerChangesErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/changes',
        ...options
    });
};

/**
 * Export a container
 *
 * Export the contents of a container as a tarball.
 */
export const containerExport = <ThrowOnError extends boolean = false>(options: Options<ContainerExportData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerExportResponses, ContainerExportErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/export',
        ...options
    });
};

/**
 * Get container stats based on resource usage
 *
 * This endpoint returns a live stream of a container’s resource usage
 * statistics.
 *
 * The `precpu_stats` is the CPU statistic of the *previous* read, and is
 * used to calculate the CPU usage percentage. It is not an exact copy
 * of the `cpu_stats` field.
 *
 * If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
 * nil then for compatibility with older daemons the length of the
 * corresponding `cpu_usage.percpu_usage` array should be used.
 *
 * On a cgroup v2 host, the following fields are not set
 * * `blkio_stats`: all fields other than `io_service_bytes_recursive`
 * * `cpu_stats`: `cpu_usage.percpu_usage`
 * * `memory_stats`: `max_usage` and `failcnt`
 * Also, `memory_stats.stats` fields are incompatible with cgroup v1.
 *
 * To calculate the values shown by the `stats` command of the docker cli tool
 * the following formulas can be used:
 * * used_memory = `memory_stats.usage - memory_stats.stats.cache`
 * * available_memory = `memory_stats.limit`
 * * Memory usage % = `(used_memory / available_memory) * 100.0`
 * * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
 * * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
 * * number_cpus = `length(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
 * * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
 *
 */
export const containerStats = <ThrowOnError extends boolean = false>(options: Options<ContainerStatsData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerStatsResponses, ContainerStatsErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/stats',
        ...options
    });
};

/**
 * Resize a container TTY
 *
 * Resize the TTY for a container.
 */
export const containerResize = <ThrowOnError extends boolean = false>(options: Options<ContainerResizeData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerResizeResponses, ContainerResizeErrors, ThrowOnError>({
        responseType: 'text',
        url: '/containers/{id}/resize',
        ...options
    });
};

/**
 * Start a container
 */
export const containerStart = <ThrowOnError extends boolean = false>(options: Options<ContainerStartData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerStartResponses, ContainerStartErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/start',
        ...options
    });
};

/**
 * Stop a container
 */
export const containerStop = <ThrowOnError extends boolean = false>(options: Options<ContainerStopData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerStopResponses, ContainerStopErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/stop',
        ...options
    });
};

/**
 * Restart a container
 */
export const containerRestart = <ThrowOnError extends boolean = false>(options: Options<ContainerRestartData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerRestartResponses, ContainerRestartErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/restart',
        ...options
    });
};

/**
 * Kill a container
 *
 * Send a POSIX signal to a container, defaulting to killing to the
 * container.
 *
 */
export const containerKill = <ThrowOnError extends boolean = false>(options: Options<ContainerKillData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerKillResponses, ContainerKillErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/kill',
        ...options
    });
};

/**
 * Update a container
 *
 * Change various configuration options of a container without having to
 * recreate it.
 *
 */
export const containerUpdate = <ThrowOnError extends boolean = false>(options: Options<ContainerUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerUpdateResponses, ContainerUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Rename a container
 */
export const containerRename = <ThrowOnError extends boolean = false>(options: Options<ContainerRenameData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerRenameResponses, ContainerRenameErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/rename',
        ...options
    });
};

/**
 * Pause a container
 *
 * Use the freezer cgroup to suspend all processes in a container.
 *
 * Traditionally, when suspending a process the `SIGSTOP` signal is used,
 * which is observable by the process being suspended. With the freezer
 * cgroup the process is unaware, and unable to capture, that it is being
 * suspended, and subsequently resumed.
 *
 */
export const containerPause = <ThrowOnError extends boolean = false>(options: Options<ContainerPauseData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerPauseResponses, ContainerPauseErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/pause',
        ...options
    });
};

/**
 * Unpause a container
 *
 * Resume a container which has been paused.
 */
export const containerUnpause = <ThrowOnError extends boolean = false>(options: Options<ContainerUnpauseData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerUnpauseResponses, ContainerUnpauseErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/unpause',
        ...options
    });
};

/**
 * Attach to a container
 *
 * Attach to a container to read its output or send it input. You can attach
 * to the same container multiple times and you can reattach to containers
 * that have been detached.
 *
 * Either the `stream` or `logs` parameter must be `true` for this endpoint
 * to do anything.
 *
 * See the [documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/)
 * for more details.
 *
 * ### Hijacking
 *
 * This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`,
 * and `stderr` on the same socket.
 *
 * This is the response from the daemon for an attach request:
 *
 * ```
 * HTTP/1.1 200 OK
 * Content-Type: application/vnd.docker.raw-stream
 *
 * [STREAM]
 * ```
 *
 * After the headers and two new lines, the TCP connection can now be used
 * for raw, bidirectional communication between the client and server.
 *
 * To hint potential proxies about connection hijacking, the Docker client
 * can also optionally send connection upgrade headers.
 *
 * For example, the client sends this request to upgrade the connection:
 *
 * ```
 * POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
 * Upgrade: tcp
 * Connection: Upgrade
 * ```
 *
 * The Docker daemon will respond with a `101 UPGRADED` response, and will
 * similarly follow with the raw stream:
 *
 * ```
 * HTTP/1.1 101 UPGRADED
 * Content-Type: application/vnd.docker.raw-stream
 * Connection: Upgrade
 * Upgrade: tcp
 *
 * [STREAM]
 * ```
 *
 * ### Stream format
 *
 * When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate),
 * the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream
 * and the stream over the hijacked connected is multiplexed to separate out
 * `stdout` and `stderr`. The stream consists of a series of frames, each
 * containing a header and a payload.
 *
 * The header contains the information which the stream writes (`stdout` or
 * `stderr`). It also contains the size of the associated frame encoded in
 * the last four bytes (`uint32`).
 *
 * It is encoded on the first eight bytes like this:
 *
 * ```go
 * header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
 * ```
 *
 * `STREAM_TYPE` can be:
 *
 * - 0: `stdin` (is written on `stdout`)
 * - 1: `stdout`
 * - 2: `stderr`
 *
 * `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size
 * encoded as big endian.
 *
 * Following the header is the payload, which is the specified number of
 * bytes of `STREAM_TYPE`.
 *
 * The simplest way to implement this protocol is the following:
 *
 * 1. Read 8 bytes.
 * 2. Choose `stdout` or `stderr` depending on the first byte.
 * 3. Extract the frame size from the last four bytes.
 * 4. Read the extracted size and output it on the correct output.
 * 5. Goto 1.
 *
 * ### Stream format when using a TTY
 *
 * When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate),
 * the stream is not multiplexed. The data exchanged over the hijacked
 * connection is simply the raw data from the process PTY and client's
 * `stdin`.
 *
 */
export const containerAttach = <ThrowOnError extends boolean = false>(options: Options<ContainerAttachData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerAttachResponses, ContainerAttachErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/attach',
        ...options
    });
};

/**
 * Attach to a container via a websocket
 */
export const containerAttachWebsocket = <ThrowOnError extends boolean = false>(options: Options<ContainerAttachWebsocketData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerAttachWebsocketResponses, ContainerAttachWebsocketErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/attach/ws',
        ...options
    });
};

/**
 * Wait for a container
 *
 * Block until a container stops, then returns the exit code.
 */
export const containerWait = <ThrowOnError extends boolean = false>(options: Options<ContainerWaitData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerWaitResponses, ContainerWaitErrors, ThrowOnError>({
        responseTransformer: containerWaitResponseTransformer,
        responseType: 'json',
        url: '/containers/{id}/wait',
        ...options
    });
};

/**
 * Remove a container
 */
export const containerDelete = <ThrowOnError extends boolean = false>(options: Options<ContainerDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<ContainerDeleteResponses, ContainerDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}',
        ...options
    });
};

/**
 * Get an archive of a filesystem resource in a container
 *
 * Get a tar archive of a resource in the filesystem of container id.
 */
export const containerArchive = <ThrowOnError extends boolean = false>(options: Options<ContainerArchiveData, ThrowOnError>) => {
    return (options.client ?? client).get<ContainerArchiveResponses, ContainerArchiveErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/archive',
        ...options
    });
};

/**
 * Get information about files in a container
 *
 * A response header `X-Docker-Container-Path-Stat` is returned, containing
 * a base64 - encoded JSON object with some filesystem header information
 * about the path.
 *
 */
export const containerArchiveInfo = <ThrowOnError extends boolean = false>(options: Options<ContainerArchiveInfoData, ThrowOnError>) => {
    return (options.client ?? client).head<ContainerArchiveInfoResponses, ContainerArchiveInfoErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/archive',
        ...options
    });
};

/**
 * Extract an archive of files or folders to a directory in a container
 *
 * Upload a tar archive to be extracted to a path in the filesystem of container id.
 * `path` parameter is asserted to be a directory. If it exists as a file, 400 error
 * will be returned with message "not a directory".
 *
 */
export const putContainerArchive = <ThrowOnError extends boolean = false>(options: Options<PutContainerArchiveData, ThrowOnError>) => {
    return (options.client ?? client).put<PutContainerArchiveResponses, PutContainerArchiveErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/archive',
        ...options,
        headers: {
            'Content-Type': 'application/x-tar',
            ...options.headers
        }
    });
};

/**
 * Delete stopped containers
 */
export const containerPrune = <ThrowOnError extends boolean = false>(options?: Options<ContainerPruneData, ThrowOnError>) => {
    return (options?.client ?? client).post<ContainerPruneResponses, ContainerPruneErrors, ThrowOnError>({
        responseTransformer: containerPruneResponseTransformer,
        responseType: 'json',
        url: '/containers/prune',
        ...options
    });
};

/**
 * List Images
 *
 * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
 */
export const imageList = <ThrowOnError extends boolean = false>(options?: Options<ImageListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ImageListResponses, ImageListErrors, ThrowOnError>({
        responseTransformer: imageListResponseTransformer,
        responseType: 'json',
        url: '/images/json',
        ...options
    });
};

/**
 * Build an image
 *
 * Build an image from a tar archive with a `Dockerfile` in it.
 *
 * The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).
 *
 * The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
 *
 * The build is canceled if the client drops the connection by quitting or being killed.
 *
 */
export const imageBuild = <ThrowOnError extends boolean = false>(options?: Options<ImageBuildData, ThrowOnError>) => {
    return (options?.client ?? client).post<ImageBuildResponses, ImageBuildErrors, ThrowOnError>({
        bodySerializer: null,
        responseType: 'json',
        url: '/build',
        ...options,
        headers: {
            'Content-type': 'application/octet-stream',
            ...options?.headers
        }
    });
};

/**
 * Delete builder cache
 */
export const buildPrune = <ThrowOnError extends boolean = false>(options?: Options<BuildPruneData, ThrowOnError>) => {
    return (options?.client ?? client).post<BuildPruneResponses, BuildPruneErrors, ThrowOnError>({
        responseTransformer: buildPruneResponseTransformer,
        responseType: 'json',
        url: '/build/prune',
        ...options
    });
};

/**
 * Create an image
 *
 * Pull or import an image.
 */
export const imageCreate = <ThrowOnError extends boolean = false>(options?: Options<ImageCreateData, ThrowOnError>) => {
    return (options?.client ?? client).post<ImageCreateResponses, ImageCreateErrors, ThrowOnError>({
        bodySerializer: null,
        querySerializer: {
            parameters: {
                changes: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        responseType: 'json',
        url: '/images/create',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Inspect an image
 *
 * Return low-level information about an image.
 */
export const imageInspect = <ThrowOnError extends boolean = false>(options: Options<ImageInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<ImageInspectResponses, ImageInspectErrors, ThrowOnError>({
        responseTransformer: imageInspectResponseTransformer,
        responseType: 'json',
        url: '/images/{name}/json',
        ...options
    });
};

/**
 * Get the history of an image
 *
 * Return parent layers of an image.
 */
export const imageHistory = <ThrowOnError extends boolean = false>(options: Options<ImageHistoryData, ThrowOnError>) => {
    return (options.client ?? client).get<ImageHistoryResponses, ImageHistoryErrors, ThrowOnError>({
        responseTransformer: imageHistoryResponseTransformer,
        responseType: 'json',
        url: '/images/{name}/history',
        ...options
    });
};

/**
 * Push an image
 *
 * Push an image to a registry.
 *
 * If you wish to push an image on to a private registry, that image must
 * already have a tag which references the registry. For example,
 * `registry.example.com/myimage:latest`.
 *
 * The push is cancelled if the HTTP connection is closed.
 *
 */
export const imagePush = <ThrowOnError extends boolean = false>(options: Options<ImagePushData, ThrowOnError>) => {
    return (options.client ?? client).post<ImagePushResponses, ImagePushErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}/push',
        ...options
    });
};

/**
 * Tag an image
 *
 * Tag an image so that it becomes part of a repository.
 */
export const imageTag = <ThrowOnError extends boolean = false>(options: Options<ImageTagData, ThrowOnError>) => {
    return (options.client ?? client).post<ImageTagResponses, ImageTagErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}/tag',
        ...options
    });
};

/**
 * Remove an image
 *
 * Remove an image, along with any untagged parent images that were
 * referenced by that image.
 *
 * Images can't be removed if they have descendant images, are being
 * used by a running container or are being used by a build.
 *
 */
export const imageDelete = <ThrowOnError extends boolean = false>(options: Options<ImageDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<ImageDeleteResponses, ImageDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}',
        ...options
    });
};

/**
 * Search images
 *
 * Search for an image on Docker Hub.
 */
export const imageSearch = <ThrowOnError extends boolean = false>(options: Options<ImageSearchData, ThrowOnError>) => {
    return (options.client ?? client).get<ImageSearchResponses, ImageSearchErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/search',
        ...options
    });
};

/**
 * Delete unused images
 */
export const imagePrune = <ThrowOnError extends boolean = false>(options?: Options<ImagePruneData, ThrowOnError>) => {
    return (options?.client ?? client).post<ImagePruneResponses, ImagePruneErrors, ThrowOnError>({
        responseTransformer: imagePruneResponseTransformer,
        responseType: 'json',
        url: '/images/prune',
        ...options
    });
};

/**
 * Check auth configuration
 *
 * Validate credentials for a registry and, if available, get an identity
 * token for accessing the registry without password.
 *
 */
export const systemAuth = <ThrowOnError extends boolean = false>(options?: Options<SystemAuthData, ThrowOnError>) => {
    return (options?.client ?? client).post<SystemAuthResponses, SystemAuthErrors, ThrowOnError>({
        responseType: 'json',
        url: '/auth',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get system information
 */
export const systemInfo = <ThrowOnError extends boolean = false>(options?: Options<SystemInfoData, ThrowOnError>) => {
    return (options?.client ?? client).get<SystemInfoResponses, SystemInfoErrors, ThrowOnError>({
        responseTransformer: systemInfoResponseTransformer,
        responseType: 'json',
        url: '/info',
        ...options
    });
};

/**
 * Get version
 *
 * Returns the version of Docker that is running and various information about the system that Docker is running on.
 */
export const systemVersion = <ThrowOnError extends boolean = false>(options?: Options<SystemVersionData, ThrowOnError>) => {
    return (options?.client ?? client).get<SystemVersionResponses, SystemVersionErrors, ThrowOnError>({
        responseType: 'json',
        url: '/version',
        ...options
    });
};

/**
 * Ping
 *
 * This is a dummy endpoint you can use to test if the server is accessible.
 */
export const systemPing = <ThrowOnError extends boolean = false>(options?: Options<SystemPingData, ThrowOnError>) => {
    return (options?.client ?? client).get<SystemPingResponses, SystemPingErrors, ThrowOnError>({
        responseType: 'text',
        url: '/_ping',
        ...options
    });
};

/**
 * Ping
 *
 * This is a dummy endpoint you can use to test if the server is accessible.
 */
export const systemPingHead = <ThrowOnError extends boolean = false>(options?: Options<SystemPingHeadData, ThrowOnError>) => {
    return (options?.client ?? client).head<SystemPingHeadResponses, SystemPingHeadErrors, ThrowOnError>({
        responseType: 'text',
        url: '/_ping',
        ...options
    });
};

/**
 * Create a new image from a container
 */
export const imageCommit = <ThrowOnError extends boolean = false>(options?: Options<ImageCommitData, ThrowOnError>) => {
    return (options?.client ?? client).post<ImageCommitResponses, ImageCommitErrors, ThrowOnError>({
        responseType: 'json',
        url: '/commit',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Monitor events
 *
 * Stream real-time events from the server.
 *
 * Various objects within Docker report events when something happens to them.
 *
 * Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `exec_die`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, `update`, and `prune`
 *
 * Images report these events: `create`, `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, `untag`, and `prune`
 *
 * Volumes report these events: `create`, `mount`, `unmount`, `destroy`, and `prune`
 *
 * Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, `remove`, and `prune`
 *
 * The Docker daemon reports these events: `reload`
 *
 * Services report these events: `create`, `update`, and `remove`
 *
 * Nodes report these events: `create`, `update`, and `remove`
 *
 * Secrets report these events: `create`, `update`, and `remove`
 *
 * Configs report these events: `create`, `update`, and `remove`
 *
 * The Builder reports `prune` events
 *
 */
export const systemEvents = <ThrowOnError extends boolean = false>(options?: Options<SystemEventsData, ThrowOnError>) => {
    return (options?.client ?? client).get<SystemEventsResponses, SystemEventsErrors, ThrowOnError>({
        responseTransformer: systemEventsResponseTransformer,
        responseType: 'json',
        url: '/events',
        ...options
    });
};

/**
 * Get data usage information
 */
export const systemDataUsage = <ThrowOnError extends boolean = false>(options?: Options<SystemDataUsageData, ThrowOnError>) => {
    return (options?.client ?? client).get<SystemDataUsageResponses, SystemDataUsageErrors, ThrowOnError>({
        responseTransformer: systemDataUsageResponseTransformer,
        responseType: 'json',
        url: '/system/df',
        ...options
    });
};

/**
 * Export an image
 *
 * Get a tarball containing all images and metadata for a repository.
 *
 * If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.
 *
 * ### Image tarball format
 *
 * An image tarball contains [Content as defined in the OCI Image Layout Specification](https://github.com/opencontainers/image-spec/blob/v1.1.1/image-layout.md#content).
 *
 * Additionally, includes the manifest.json file associated with a backwards compatible docker save format.
 *
 * If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.
 *
 * ```json
 * {
 * "hello-world": {
 * "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
 * }
 * }
 * ```
 *
 */
export const imageGet = <ThrowOnError extends boolean = false>(options: Options<ImageGetData, ThrowOnError>) => {
    return (options.client ?? client).get<ImageGetResponses, ImageGetErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/images/{name}/get',
        ...options
    });
};

/**
 * Export several images
 *
 * Get a tarball containing all images and metadata for several image
 * repositories.
 *
 * For each value of the `names` parameter: if it is a specific name and
 * tag (e.g. `ubuntu:latest`), then only that image (and its parents) are
 * returned; if it is an image ID, similarly only that image (and its parents)
 * are returned and there would be no names referenced in the 'repositories'
 * file for this image ID.
 *
 * For details on the format, see the [export image endpoint](#operation/ImageGet).
 *
 */
export const imageGetAll = <ThrowOnError extends boolean = false>(options?: Options<ImageGetAllData, ThrowOnError>) => {
    return (options?.client ?? client).get<ImageGetAllResponses, ImageGetAllErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                names: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        responseType: 'blob',
        url: '/images/get',
        ...options
    });
};

/**
 * Import images
 *
 * Load a set of images and tags into a repository.
 *
 * For details on the format, see the [export image endpoint](#operation/ImageGet).
 *
 */
export const imageLoad = <ThrowOnError extends boolean = false>(options?: Options<ImageLoadData, ThrowOnError>) => {
    return (options?.client ?? client).post<ImageLoadResponses, ImageLoadErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/load',
        ...options,
        headers: {
            'Content-Type': 'application/x-tar',
            ...options?.headers
        }
    });
};

/**
 * Create an exec instance
 *
 * Run a command inside a running container.
 */
export const containerExec = <ThrowOnError extends boolean = false>(options: Options<ContainerExecData, ThrowOnError>) => {
    return (options.client ?? client).post<ContainerExecResponses, ContainerExecErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/exec',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Start an exec instance
 *
 * Starts a previously set up exec instance. If detach is true, this endpoint
 * returns immediately after starting the command. Otherwise, it sets up an
 * interactive session with the command.
 *
 */
export const execStart = <ThrowOnError extends boolean = false>(options: Options<ExecStartData, ThrowOnError>) => {
    return (options.client ?? client).post<ExecStartResponses, ExecStartErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/exec/{id}/start',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Resize an exec instance
 *
 * Resize the TTY session used by an exec instance. This endpoint only works
 * if `tty` was specified as part of creating and starting the exec instance.
 *
 */
export const execResize = <ThrowOnError extends boolean = false>(options: Options<ExecResizeData, ThrowOnError>) => {
    return (options.client ?? client).post<ExecResizeResponses, ExecResizeErrors, ThrowOnError>({
        responseType: 'json',
        url: '/exec/{id}/resize',
        ...options
    });
};

/**
 * Inspect an exec instance
 *
 * Return low-level information about an exec instance.
 */
export const execInspect = <ThrowOnError extends boolean = false>(options: Options<ExecInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<ExecInspectResponses, ExecInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/exec/{id}/json',
        ...options
    });
};

/**
 * List volumes
 */
export const volumeList = <ThrowOnError extends boolean = false>(options?: Options<VolumeListData, ThrowOnError>) => {
    return (options?.client ?? client).get<VolumeListResponses, VolumeListErrors, ThrowOnError>({
        responseTransformer: volumeListResponseTransformer,
        responseType: 'json',
        url: '/volumes',
        ...options
    });
};

/**
 * Create a volume
 */
export const volumeCreate = <ThrowOnError extends boolean = false>(options: Options<VolumeCreateData, ThrowOnError>) => {
    return (options.client ?? client).post<VolumeCreateResponses, VolumeCreateErrors, ThrowOnError>({
        responseTransformer: volumeCreateResponseTransformer,
        responseType: 'json',
        url: '/volumes/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Remove a volume
 *
 * Instruct the driver to remove the volume.
 */
export const volumeDelete = <ThrowOnError extends boolean = false>(options: Options<VolumeDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<VolumeDeleteResponses, VolumeDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/{name}',
        ...options
    });
};

/**
 * Inspect a volume
 */
export const volumeInspect = <ThrowOnError extends boolean = false>(options: Options<VolumeInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<VolumeInspectResponses, VolumeInspectErrors, ThrowOnError>({
        responseTransformer: volumeInspectResponseTransformer,
        responseType: 'json',
        url: '/volumes/{name}',
        ...options
    });
};

/**
 * "Update a volume. Valid only for Swarm cluster volumes"
 *
 */
export const volumeUpdate = <ThrowOnError extends boolean = false>(options: Options<VolumeUpdateData, ThrowOnError>) => {
    return (options.client ?? client).put<VolumeUpdateResponses, VolumeUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/{name}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete unused volumes
 */
export const volumePrune = <ThrowOnError extends boolean = false>(options?: Options<VolumePruneData, ThrowOnError>) => {
    return (options?.client ?? client).post<VolumePruneResponses, VolumePruneErrors, ThrowOnError>({
        responseTransformer: volumePruneResponseTransformer,
        responseType: 'json',
        url: '/volumes/prune',
        ...options
    });
};

/**
 * List networks
 *
 * Returns a list of networks. For details on the format, see the
 * [network inspect endpoint](#operation/NetworkInspect).
 *
 * Note that it uses a different, smaller representation of a network than
 * inspecting a single network. For example, the list of containers attached
 * to the network is not propagated in API versions 1.28 and up.
 *
 */
export const networkList = <ThrowOnError extends boolean = false>(options?: Options<NetworkListData, ThrowOnError>) => {
    return (options?.client ?? client).get<NetworkListResponses, NetworkListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks',
        ...options
    });
};

/**
 * Remove a network
 */
export const networkDelete = <ThrowOnError extends boolean = false>(options: Options<NetworkDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<NetworkDeleteResponses, NetworkDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}',
        ...options
    });
};

/**
 * Inspect a network
 */
export const networkInspect = <ThrowOnError extends boolean = false>(options: Options<NetworkInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<NetworkInspectResponses, NetworkInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}',
        ...options
    });
};

/**
 * Create a network
 */
export const networkCreate = <ThrowOnError extends boolean = false>(options: Options<NetworkCreateData, ThrowOnError>) => {
    return (options.client ?? client).post<NetworkCreateResponses, NetworkCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Connect a container to a network
 *
 * The network must be either a local-scoped network or a swarm-scoped network with the `attachable` option set. A network cannot be re-attached to a running container
 */
export const networkConnect = <ThrowOnError extends boolean = false>(options: Options<NetworkConnectData, ThrowOnError>) => {
    return (options.client ?? client).post<NetworkConnectResponses, NetworkConnectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}/connect',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Disconnect a container from a network
 */
export const networkDisconnect = <ThrowOnError extends boolean = false>(options: Options<NetworkDisconnectData, ThrowOnError>) => {
    return (options.client ?? client).post<NetworkDisconnectResponses, NetworkDisconnectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}/disconnect',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete unused networks
 */
export const networkPrune = <ThrowOnError extends boolean = false>(options?: Options<NetworkPruneData, ThrowOnError>) => {
    return (options?.client ?? client).post<NetworkPruneResponses, NetworkPruneErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/prune',
        ...options
    });
};

/**
 * List plugins
 *
 * Returns information about installed plugins.
 */
export const pluginList = <ThrowOnError extends boolean = false>(options?: Options<PluginListData, ThrowOnError>) => {
    return (options?.client ?? client).get<PluginListResponses, PluginListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins',
        ...options
    });
};

/**
 * Get plugin privileges
 */
export const getPluginPrivileges = <ThrowOnError extends boolean = false>(options: Options<GetPluginPrivilegesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPluginPrivilegesResponses, GetPluginPrivilegesErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/privileges',
        ...options
    });
};

/**
 * Install a plugin
 *
 * Pulls and installs a plugin. After the plugin is installed, it can be
 * enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
 *
 */
export const pluginPull = <ThrowOnError extends boolean = false>(options: Options<PluginPullData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginPullResponses, PluginPullErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/pull',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Inspect a plugin
 */
export const pluginInspect = <ThrowOnError extends boolean = false>(options: Options<PluginInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<PluginInspectResponses, PluginInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/json',
        ...options
    });
};

/**
 * Remove a plugin
 */
export const pluginDelete = <ThrowOnError extends boolean = false>(options: Options<PluginDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<PluginDeleteResponses, PluginDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}',
        ...options
    });
};

/**
 * Enable a plugin
 */
export const pluginEnable = <ThrowOnError extends boolean = false>(options: Options<PluginEnableData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginEnableResponses, PluginEnableErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/enable',
        ...options
    });
};

/**
 * Disable a plugin
 */
export const pluginDisable = <ThrowOnError extends boolean = false>(options: Options<PluginDisableData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginDisableResponses, PluginDisableErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/disable',
        ...options
    });
};

/**
 * Upgrade a plugin
 */
export const pluginUpgrade = <ThrowOnError extends boolean = false>(options: Options<PluginUpgradeData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginUpgradeResponses, PluginUpgradeErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create a plugin
 */
export const pluginCreate = <ThrowOnError extends boolean = false>(options: Options<PluginCreateData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginCreateResponses, PluginCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/create',
        ...options,
        headers: {
            'Content-Type': 'application/x-tar',
            ...options.headers
        }
    });
};

/**
 * Push a plugin
 *
 * Push a plugin to the registry.
 *
 */
export const pluginPush = <ThrowOnError extends boolean = false>(options: Options<PluginPushData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginPushResponses, PluginPushErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/push',
        ...options
    });
};

/**
 * Configure a plugin
 */
export const pluginSet = <ThrowOnError extends boolean = false>(options: Options<PluginSetData, ThrowOnError>) => {
    return (options.client ?? client).post<PluginSetResponses, PluginSetErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/set',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List nodes
 */
export const nodeList = <ThrowOnError extends boolean = false>(options?: Options<NodeListData, ThrowOnError>) => {
    return (options?.client ?? client).get<NodeListResponses, NodeListErrors, ThrowOnError>({
        responseTransformer: nodeListResponseTransformer,
        responseType: 'json',
        url: '/nodes',
        ...options
    });
};

/**
 * Delete a node
 */
export const nodeDelete = <ThrowOnError extends boolean = false>(options: Options<NodeDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<NodeDeleteResponses, NodeDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/nodes/{id}',
        ...options
    });
};

/**
 * Inspect a node
 */
export const nodeInspect = <ThrowOnError extends boolean = false>(options: Options<NodeInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<NodeInspectResponses, NodeInspectErrors, ThrowOnError>({
        responseTransformer: nodeInspectResponseTransformer,
        responseType: 'json',
        url: '/nodes/{id}',
        ...options
    });
};

/**
 * Update a node
 */
export const nodeUpdate = <ThrowOnError extends boolean = false>(options: Options<NodeUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<NodeUpdateResponses, NodeUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/nodes/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Inspect swarm
 */
export const swarmInspect = <ThrowOnError extends boolean = false>(options?: Options<SwarmInspectData, ThrowOnError>) => {
    return (options?.client ?? client).get<SwarmInspectResponses, SwarmInspectErrors, ThrowOnError>({
        responseTransformer: swarmInspectResponseTransformer,
        responseType: 'json',
        url: '/swarm',
        ...options
    });
};

/**
 * Initialize a new swarm
 */
export const swarmInit = <ThrowOnError extends boolean = false>(options: Options<SwarmInitData, ThrowOnError>) => {
    return (options.client ?? client).post<SwarmInitResponses, SwarmInitErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Join an existing swarm
 */
export const swarmJoin = <ThrowOnError extends boolean = false>(options: Options<SwarmJoinData, ThrowOnError>) => {
    return (options.client ?? client).post<SwarmJoinResponses, SwarmJoinErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/join',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Leave a swarm
 */
export const swarmLeave = <ThrowOnError extends boolean = false>(options?: Options<SwarmLeaveData, ThrowOnError>) => {
    return (options?.client ?? client).post<SwarmLeaveResponses, SwarmLeaveErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/leave',
        ...options
    });
};

/**
 * Update a swarm
 */
export const swarmUpdate = <ThrowOnError extends boolean = false>(options: Options<SwarmUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<SwarmUpdateResponses, SwarmUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get the unlock key
 */
export const swarmUnlockkey = <ThrowOnError extends boolean = false>(options?: Options<SwarmUnlockkeyData, ThrowOnError>) => {
    return (options?.client ?? client).get<SwarmUnlockkeyResponses, SwarmUnlockkeyErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/unlockkey',
        ...options
    });
};

/**
 * Unlock a locked manager
 */
export const swarmUnlock = <ThrowOnError extends boolean = false>(options: Options<SwarmUnlockData, ThrowOnError>) => {
    return (options.client ?? client).post<SwarmUnlockResponses, SwarmUnlockErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/unlock',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List services
 */
export const serviceList = <ThrowOnError extends boolean = false>(options?: Options<ServiceListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ServiceListResponses, ServiceListErrors, ThrowOnError>({
        responseTransformer: serviceListResponseTransformer,
        responseType: 'json',
        url: '/services',
        ...options
    });
};

/**
 * Create a service
 */
export const serviceCreate = <ThrowOnError extends boolean = false>(options: Options<ServiceCreateData, ThrowOnError>) => {
    return (options.client ?? client).post<ServiceCreateResponses, ServiceCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a service
 */
export const serviceDelete = <ThrowOnError extends boolean = false>(options: Options<ServiceDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<ServiceDeleteResponses, ServiceDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/{id}',
        ...options
    });
};

/**
 * Inspect a service
 */
export const serviceInspect = <ThrowOnError extends boolean = false>(options: Options<ServiceInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<ServiceInspectResponses, ServiceInspectErrors, ThrowOnError>({
        responseTransformer: serviceInspectResponseTransformer,
        responseType: 'json',
        url: '/services/{id}',
        ...options
    });
};

/**
 * Update a service
 */
export const serviceUpdate = <ThrowOnError extends boolean = false>(options: Options<ServiceUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<ServiceUpdateResponses, ServiceUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get service logs
 *
 * Get `stdout` and `stderr` logs from a service. See also
 * [`/containers/{id}/logs`](#operation/ContainerLogs).
 *
 * **Note**: This endpoint works only for services with the `local`,
 * `json-file` or `journald` logging drivers.
 *
 */
export const serviceLogs = <ThrowOnError extends boolean = false>(options: Options<ServiceLogsData, ThrowOnError>) => {
    return (options.client ?? client).get<ServiceLogsResponses, ServiceLogsErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/services/{id}/logs',
        ...options
    });
};

/**
 * List tasks
 */
export const taskList = <ThrowOnError extends boolean = false>(options?: Options<TaskListData, ThrowOnError>) => {
    return (options?.client ?? client).get<TaskListResponses, TaskListErrors, ThrowOnError>({
        responseTransformer: taskListResponseTransformer,
        responseType: 'json',
        url: '/tasks',
        ...options
    });
};

/**
 * Inspect a task
 */
export const taskInspect = <ThrowOnError extends boolean = false>(options: Options<TaskInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<TaskInspectResponses, TaskInspectErrors, ThrowOnError>({
        responseTransformer: taskInspectResponseTransformer,
        responseType: 'json',
        url: '/tasks/{id}',
        ...options
    });
};

/**
 * Get task logs
 *
 * Get `stdout` and `stderr` logs from a task.
 * See also [`/containers/{id}/logs`](#operation/ContainerLogs).
 *
 * **Note**: This endpoint works only for services with the `local`,
 * `json-file` or `journald` logging drivers.
 *
 */
export const taskLogs = <ThrowOnError extends boolean = false>(options: Options<TaskLogsData, ThrowOnError>) => {
    return (options.client ?? client).get<TaskLogsResponses, TaskLogsErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/tasks/{id}/logs',
        ...options
    });
};

/**
 * List secrets
 */
export const secretList = <ThrowOnError extends boolean = false>(options?: Options<SecretListData, ThrowOnError>) => {
    return (options?.client ?? client).get<SecretListResponses, SecretListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets',
        ...options
    });
};

/**
 * Create a secret
 */
export const secretCreate = <ThrowOnError extends boolean = false>(options?: Options<SecretCreateData, ThrowOnError>) => {
    return (options?.client ?? client).post<SecretCreateResponses, SecretCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a secret
 */
export const secretDelete = <ThrowOnError extends boolean = false>(options: Options<SecretDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<SecretDeleteResponses, SecretDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/{id}',
        ...options
    });
};

/**
 * Inspect a secret
 */
export const secretInspect = <ThrowOnError extends boolean = false>(options: Options<SecretInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<SecretInspectResponses, SecretInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/{id}',
        ...options
    });
};

/**
 * Update a Secret
 */
export const secretUpdate = <ThrowOnError extends boolean = false>(options: Options<SecretUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<SecretUpdateResponses, SecretUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List configs
 */
export const configList = <ThrowOnError extends boolean = false>(options?: Options<ConfigListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ConfigListResponses, ConfigListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs',
        ...options
    });
};

/**
 * Create a config
 */
export const configCreate = <ThrowOnError extends boolean = false>(options?: Options<ConfigCreateData, ThrowOnError>) => {
    return (options?.client ?? client).post<ConfigCreateResponses, ConfigCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a config
 */
export const configDelete = <ThrowOnError extends boolean = false>(options: Options<ConfigDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<ConfigDeleteResponses, ConfigDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/{id}',
        ...options
    });
};

/**
 * Inspect a config
 */
export const configInspect = <ThrowOnError extends boolean = false>(options: Options<ConfigInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<ConfigInspectResponses, ConfigInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/{id}',
        ...options
    });
};

/**
 * Update a Config
 */
export const configUpdate = <ThrowOnError extends boolean = false>(options: Options<ConfigUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<ConfigUpdateResponses, ConfigUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get image information from the registry
 *
 * Return image digest and platform information by contacting the registry.
 *
 */
export const distributionInspect = <ThrowOnError extends boolean = false>(options: Options<DistributionInspectData, ThrowOnError>) => {
    return (options.client ?? client).get<DistributionInspectResponses, DistributionInspectErrors, ThrowOnError>({
        responseTransformer: distributionInspectResponseTransformer,
        responseType: 'json',
        url: '/distribution/{name}/json',
        ...options
    });
};

/**
 * Initialize interactive session
 *
 * Start a new interactive session with a server. Session allows server to
 * call back to the client for advanced capabilities.
 *
 * ### Hijacking
 *
 * This endpoint hijacks the HTTP connection to HTTP2 transport that allows
 * the client to expose gPRC services on that connection.
 *
 * For example, the client sends this request to upgrade the connection:
 *
 * ```
 * POST /session HTTP/1.1
 * Upgrade: h2c
 * Connection: Upgrade
 * ```
 *
 * The Docker daemon responds with a `101 UPGRADED` response follow with
 * the raw stream:
 *
 * ```
 * HTTP/1.1 101 UPGRADED
 * Connection: Upgrade
 * Upgrade: h2c
 * ```
 *
 */
export const session = <ThrowOnError extends boolean = false>(options?: Options<SessionData, ThrowOnError>) => {
    return (options?.client ?? client).post<unknown, SessionErrors, ThrowOnError>({
        url: '/session',
        ...options
    });
};
